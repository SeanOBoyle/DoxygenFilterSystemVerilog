// $Id_deleteme$
//----------------------------------------------------------------------------
//    This program is free software: you can redistribute it and/or modify
//    it under the terms of the GNU General Public License as published by
//    the Free Software Foundation, either version 3 of the License, or
//    (at your option) any later version.
//
//    This program is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU General Public License for more details.
//
//    You should have received a copy of the GNU General Public License
//    along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
//----------------------------------------------------------------------------
// NOTE: 'deleteme' comments added to prevent SVN from changing text (where the sv and golden would result in a mismatch)
/**
 * Test.
 * This file is a test of the doxygen filter script.<br>
 * This contains a semi-complete set of the SystemVerilog constructs
 * that the filter script can handle<br>
 * <br>
 * <br>
 * @par Download the most recent version here:
 * http://intelligentdv.com/downloads/
 * <br>
 * @par File Bugs Here:
 * http://bugs.intelligentdv.com/ <br>
 * Project:  DoxygenFilter
 *
 * @file test.sv
 * @author Sean O'Boyle
 * @par Contact:
 * http://intelligentdv.com/contact/
 * @par Company:
 * <a href="http://intelligentdv.com">Intelligent Design Verification</a>
 *
 * @version
 * $LastChangedRevision_deleteme$
 * @par Last Change Date:
 * $LastChangedDate_deleteme$
 * @par Last Change By:
 * $LastChangedBy_deleteme$
 *
 */

#ifndef TEST__SV
#define TEST__SV





#define PUTINQUOTES(x) #x

#include "myfile.sv"
#define MYOTHERFILE myotherfile.sv
#include PUTINQUOTES(MYOTHERFILE)


// DPI Import
 int dpi_method1(input string str1, input string regex) {}
 string dpi_method2() {}
 string dpi_method3() {}
 string dpi_method4(int n) {}
 void myInit() {}
// from standard math library
 real sin(real) {}
// from standard C library: memory management
 chandle malloc(int size); // standard C function
 void free(chandle ptr); // standard C function
// abstract data structure: queue
 chandle newQueue(input string name_of_queue) {}
// Note the following import uses the same foreign function for
// implementation as the prior import, but has different SystemVerilog name
// and provides a default value for the argument.
 chandle newAnonQueue(input string s=null) {}
 chandle newElem(bit <15:0> ) {}
 void enqueue(chandle queue, chandle elem) {}
 chandle dequeue(chandle queue) {}
// miscellanea
 bit <15:0>  getStimulus() {}
 void processTransaction(chandle elem,
                                       output logic <64:1>  arr [0:63]) {}
task checkResults(input string s, bit <511:0>  packet) {}


// DPI Export


// Macros
#define MYDEFINE mydefine
#ifdef MYDEFINE
#define MYDEFINE2 mydefine2
#else
#undef MYDEFINE2
#endif

// More Macros
#define foo(f) f##_suffix
#define msg(x,y) "x: \"y\""

// Multiline Macros (from VMM)
#ifndef __FILE__
#define __FILE__ ""
#endif
#ifndef __LINE__
#define __LINE__ -1
#endif

#define vmm_warning(log, msg)  \
do \
   /* synopsys translate_off */ \
   if (log.start_msg(vmm_log::FAILURE_TYP, vmm_log::WARNING_SEV, __FILE__, __LINE__)) { \
      void(log.text(msg)); \
      log.end_msg(); // a comment in a macro \
   } \
   /* synopsys translate_on */ \
while(0)

#define vmm_error(log, msg)  \
do \
   /* synopsys translate_off */ \
   if (log.start_msg(vmm_log::FAILURE_TYP, vmm_log::ERROR_SEV, __FILE__, __LINE__)) { \
      void(log.text(msg)); \
      log.end_msg(); \
   } \
   /* synopsys translate_on */ \
while (0)

#define vmm_fatal(log, msg)  \
do \
   /* synopsys translate_off */ \
   if (log.start_msg(vmm_log::FAILURE_TYP, vmm_log::FATAL_SEV, __FILE__, __LINE__)) { \
      void(log.text(msg)); \
      log.end_msg(); \
   } \
   /* synopsys translate_on */ \
while (0)

// Another Mulitline Macro (from VMM)
#define vmm_channel(T) \
class vmm_channel_(T) : public vmm_channel { public:  \
 \
    new(string name, \
                string inst, \
                int    full = 1, \
                int    empty = 0, \
                bit    fill_as_bytes = 0) { \
      super.new(name, inst, full, empty, fill_as_bytes); \
   } \
 \
    T unput(int offset = -1) { \
      $cast(unput, super.unput(offset)); \
   } \
 \
   constraint myconstraint() {  \
      depth == 3; \
      foo == 5; \
   } \
   \
   task get(output T obj, input int offset = 0) { \
      vmm_data o; \
      super.get(o, offset); \
      $cast(obj, o); \
   } \
   \
    covergroup mycov() { \
      coverpoint m_depth; \
      coverpoint m_full; \
   } \
 \
   task peek(output T obj, input int offset = 0) { \
      vmm_data o; \
      super.peek(o, offset); \
      $cast(obj, o); \
   } \
 \
   task activate(output T obj, input int offset = 0) { \
      vmm_data o; \
      super.activate(o, offset); \
      $cast(obj, o); \
   } \
 \
    T active_slot() { \
      $cast(active_slot, super.active_slot()); \
   } \
 \
    T start() { \
      $cast(start, super.start()); \
   } \
 \
    T complete(vmm_data status = null) { \
      $cast(complete, super.complete(status)); \
   } \
 \
    T remove() { \
      $cast(remove, super.remove()); \
   } \
 \
   task tee(output T obj) { \
      vmm_data o; \
      super.tee(o); \
      $cast(obj, o); \
   } \
 \
    T for_each(bit reset = 0) { \
      $cast(for_each, super.for_each(reset)); \
   } \
 \
};


/**
 *  Test Class - Basic.
 *  Just a basic class declaration.<br>
 *  "String in Quotes in a comment"
 *
 *  @class test_class_basic
 *
 */
class test_class_basic { public: 

   // Test Member Access Specifiers
private:     rand int     m_local_int;      ///< Private Int
protected:     rand int m_protected_int;  ///< Protected Int
    rand bit m_protected_bit;  ///< Protected Bit
public:          event   m_public_event;   ///< Public Event
private:     event   m_local_event;    ///< Private Event
public:          int     m_int_array [1:32];
   // Test bitvector brace conversion
         rand bit <31:0>  m_public_bitvector; ///< Public Bit Vector
   // Test enum typedef
   typedef enum {A, ///< A State
                  B, ///< B State
                  C, ///< C State
                  D  ///< D State
                 } alpha_enum_t;  ///< Alpha State Enum Type
   
   typedef enum { M, ///< M State
                            N  ///< N State
                            } mn_enum_t; ///< Bit State Enum Type

   alpha_enum_t m_alpha; ///< Alpha State
   mn_enum_t    m_mn;    ///< MN State

   /**
    * Small Int Constraint.
    * Constrain m_local_int to a small value.
    *
    */
   constraint small_int() { m_local_int <= 0d6;}

   /**
    * Word Align Constraint.
    * Constrain m_public_bitvector to word align
    *
    */
   constraint word_align() { 
      // This is a comment
      m_public_bitvector[2] == 0d0;
   }

   /**
    * Extern Constraint.
    * Constraint body defined extern.
    *
    */
   constraint extern_constraint();
   
   /**
    * Cov1 Coverage Group.
    * Covers m_alpha and m_mn
    *
    */
    covergroup cov1() {
      coverpoint m_alpha;
      coverpoint m_mn;
   }

   /**
    * Cov2 Coverage Group.
    * Covers m_protected_bit and m_protected_int on m_protected_bit event.
    *
    */
    covergroup cov2 () {
      coverpoint m_protected_bit;
      coverpoint m_protected_int;
   }

   /**
    * Cov3 Coverage Group with args.
    * Covers m_protected_bit and m_protected_int on m_protected_bit event.
    *
    */
    covergroup cov3 (int arg1, int arg2) {
      coverpoint m_protected_bit;
      coverpoint m_protected_int;
   }

   /**
    * Cov4 Coverage Group with args on 2 lines.
    * Covers m_protected_bit and m_protected_int on m_protected_bit event.
    *
    */
    covergroup cov4 (int arg1,
                    int arg2) {
      coverpoint m_protected_bit;
      coverpoint m_protected_int;
   }

   /**
    * Cov5 Coverage Group with args on with sampling.
    * Covers m_protected_bit and m_protected_int on m_protected_bit event.
    *
    */
    covergroup cov5 (int arg1,
                    int arg2)  {
      coverpoint m_protected_bit;
      coverpoint m_protected_int;
   }

   /**
    *  Constructor.
    *  Class Constructor<br>
    *
    *  @param myint int - My Integer Parameter
    *  @param mybit bit - My Bit Parameter (defaults to 0)
    */
    new(time myint, bit mybit = 0) {
      m_local_int = myint;
      m_protected_bit = mybit;
      cov1 = new;
      cov2 = new;
   }

   /**
    *  Protected Extern Function.
    *  Test extern function<br>
    *  Test method access specifier
    *
    *  @return void
    *
    */
protected:      void myprotectedexternfunction();
public: 
   /**
    *  Extern Function.
    *  Test extern function<br>
    *  Test method access specifier
    *
    *  @return void
    *
    */
private:      void myexternfunction();
public: 
   /**
    *  Public Task.
    *  Test method access specifier.<br>
    *  Test virtual method specifier.
    *
    *  @return void
    *
    */
   virtual task mypublicvirtualfunction() {
      $display("This is public");
   }
   
   /**
    *  Pure Virtual Task.
    *  Test pure virtual specifier
    *
    *  @return void
    *
    */
   virtual task mypurevirtualtask() = 0;
   
   /**
    *  Protected Task.
    *  Test method access specifier
    *
    *  @return void
    *
    */
protected:     task myprotectedfunction() {
      $display("This is protected");
   }
public:    
   /**
    *  Protected Task.
    *  Test method access specifier
    *
    *  @return void
    *
    */
protected:     task myprotectedfunction() {
      $display("This is protected");
   }
public: 
   /**
    *  Pure Virtual Function.
    *  Test pure virtual specifier
    *
    *  @return void
    *
    */
   virtual  int mypurevirtualfunction(int A,
                                                   int B) = 0;


   /**
    *  local function.
    *  Test method access specifier
    *
    *  @return void
    *
    */
private:      void myprivatefunction() {
      $display("This is private");
   }
public: 
   /**
    *  Virtual Function.
    *  Test Virtual Function<br>
    *  Test bit vector braces<br>
    *  Test literals with tickmark (')<br>
    */
    virtual  void myvirtualfunction() {
       int myint = 0d3;
       bit <7:0>   mybitvector = 0xX;
       bit <15:0>  mybitvector2 = 0xBEEF;
       bit <31:0>  mybitvector3 = 0o3355;
       {
          bit <1:0>   mybitvector4 = 0b01;
          bit <1:0>   mybitvecotr5 = 0b10;
       }
    }

};

constraint test_class_basic::extern_constraint() { 
   m_local_int == m_protected_int;
}

// Extern Function show()
// Test string in quotes
 void test_class_basic::myexternfunction() {
   $display("test::show()");
   $display("m_local_int %0d", m_local_int);
   {
      $display("m_protected_int %0d", m_protected_int);
      $display("m_protected_bit %0b", m_protected_bit);
   }
   $display("");
}

 void test_class_basic::myprotectedexternfunction() {
   // Cast from bit to int
   int myint;
   bit <7:0>  mybitvector;

   myint = int(m_mn);
   mybitvector = bit <7:0> (m_alpha);
   
}

/**
 * MyProgram1 Program Block.
 * Just a program block with no inputs/outputs
 */
/** @ingroup SVprogram */program myprogram1() {
   {
     int myint = 5; 
     int myint2 = 6;
     $display("Hello World");
     case  (myint) { 
        0: myint2 = 1;
        1: myint2 = 0;
        default: myint2 = 2;
     }
  }
}

/**
 * MyProgram2 Program Block.
 * A program block with inputs/outputs declared over multiple lines
 */
/** @ingroup SVprogram */program myprogram2(int myint,
                   bit mybit) {
   {
     $display("Hello World");
  }
   {
     $display("Goodbye World");
  }
}

/**
 * MyModule1 Module Block.
 * Just a module block with no inputs/outputs
 */
/** @ingroup SVmodule */module mymodule1() {
    {
      $display("Hello World");
   }
}

/**
 * MyModule2 Module Block.
 * A module block with inputs/outputs declared over multiple lines
 */
/** @ingroup SVmodule */module mymodule2(int myint,
                bit mybit) {
    bus_A mybus;
    {
      $display("Hello World");
   }
}

/**
 * Bus interface Block.
 * An interface with no ports.
 */
/** @ingroup SVinterface */interface bus() {
      logic <15:0>  data;
      logic write;
      modport test (input data, output write);
      modport dut (output data, input write);
}

/**
 * BusA interface Block.
 * An interface with single clock input.
 */
/** @ingroup SVinterface */interface bus_A(input clk) {
      logic <15:0>  data;
      logic write;
      modport test (input data, output write);
      modport dut (output data, input write);
}

/**
 * BusB interface Block.
 * An interface with two lines of I/O
 */
/** @ingroup SVinterface */interface bus_B(input clk,
                 output foo) {
      logic <8:1>  cmd;
      logic enable;
      logic foo;
      modport test (input enable);
      modport dut (output enable);
}

/**
 * BusC interface Block.
 * A parameterized interface in one line
 */
/** @ingroup SVinterface */template <WIDTH=8> interface bus_C(input clk, output foo) {
      logic <WDTH-1:0>  cmd;
      logic enable;
      modport test (input enable);
      modport dut (output enable);
}

/**
 * BusD interface Block.
 * A parameterized interface with two lines of IO
 */
/** @ingroup SVinterface */template <WIDTH=8> interface bus_D(input clk, 
                            output foo) {
      logic <WDTH-1:0>  cmd;
      logic enable;
      modport test (input enable);
      modport dut (output enable);
}

/**
 * BusE interface Block.
 * A parameterized interface with two lines of parameters and one lines of IO
 */
/** @ingroup SVinterface */template <WIDTH=8,
                  DEPTH=20> interface bus_E  (input clk, output foo) {
      logic <WDTH-1:0>  cmd;
      logic enable;
      logic arr [DEPTH];
      modport test (input enable);
      modport dut (output enable);
}

/**
 * BusF interface Block.
 * A parameterized interface with two lines of parameters and two lines of IO
 */
/** @ingroup SVinterface */template <WIDTH=8,
                  DEPTH=20> interface bus_F  (input clk,
                             output foo) {
      logic <WDTH-1:0>  cmd;
      logic enable;
      logic arr [DEPTH];
      modport test (input enable);
      modport dut (output enable);
}

/**
 * My Derived Class.
 * Extends test_class_basic
 */
class myderivedclass : public test_class_basic { public: 
   int m_myint;
   bit m_mybit;
};

/**
 * My Derived Class Package.
 * Extends foo::test_class_basic -- foo:: will be removed
 */
class myderivedclass_package : public test_class_basic { public: 
   int m_myint;
   bit m_mybit;
};

/**
 * My Template Class.
 * type T=int
 * extends test_class_basic
 */
template  <typename T=int> class mytemplateclass : public test_class_basic { public: 
   int m_myint;
   bit m_mybit;
};

/**
 * My Template Class2.
 * type T=custom
 * extends mytemplateclass#(bit)
 */
template  <typename T=custom> class mytemplateclass2 : public mytemplateclass<bit>  { public: 
   int m_myint;
   bit m_mybit;
};

/**
 * My Template Class3.
 * type T=int, type B=bit
 * extends mytemplateclass#(bit)
 */
template  <typename T=int, typename B=bit> class mytemplateclass3 : public mytemplateclass<bit>  { public: 
   int m_myint;
   bit m_mybit;
};

/**
 * My Template Class4.
 * type T=int
 * extends nothing...
 */
template  <typename T=int> class mytemplateclass4   { public: 
   int m_myint;
   bit m_mybit;
};

/**
 * My Template Class5.
 * int B=3
 * extends nothing...
 */
template  <int B=3> class mytemplateclass5   { public: 
   int m_myint;
   bit m_mybit;
};

/**
 * My Template Class6.
 * type T=int, int B=3
 * extends nothing...
 */
template  <typename T=int, int B=3> class mytemplateclass6   { public: 
   int m_myint;
   bit m_mybit;
};

/**
 * My Template Class7.
 * type T=int, int B=3
 * extends mytemplateclass#(bit)
 */
template  <typename T=int, int B=3> class mytemplateclass7 : public mytemplateclass <bit>  { public: 
   int m_myint;
   bit m_mybit;
};

/**
 * My Template Class8.
 * type T=int, int B=3, type C=mine
 * extends mytemplateclass4#(bit, 5)
 */
template  <typename T=int,
                         int B=3,
                         typename C=mine> class mytemplateclass8  
                         : public mytemplateclass6<bit,
                                                   5>  { public: 
   int m_myint;
   bit m_mybit;
};

/**
 * My Template Class9.
 * type T=int, int B=3, type C=mine
 * extends mytemplateclass4#(bit, 5)
 */
template  <typename T=int,
                         int B=3,
                         typename C=mine> class mytemplateclass9  
                         : public mytemplateclass6<bit,5>  { public: 
   int m_myint;
   bit m_mybit;
};

/**
 * My Template Class10.
 * type T=int, int B=3, type C=mine
 * extends nothing...
 */
template  <typename T=int,
                         int B=3,
                         typename C=mine> class mytemplateclass10   { public: 
   int m_myint;
   bit m_mybit;
};

/**
 * My Class11.
 * extends template class...
 */
class myclass11 : public mytemplateclass10 <foo, 5, boo>  { public: 
   int m_myint;
};


template  <typename ABC=data, typename DEF=data2> class mytemplateselectclass  
#ifdef DEFBASE
  : public DEFBASE
#endif
 { public: 
   int m_myint;
};

class myselectclass
#ifdef DEFBASE
  : public DEFBASE
#endif
 { public: 
   int m_myint;
};

template  <typename f = null, typename g = z, typename h = x> class abc : public def <f>  { public: 
   int m_myint;
};

#endif


/** @defgroup SVinterface Interfaces */
/** @defgroup SVprogram Programs */
/** @defgroup SVmodule Modules */
